#!/usr/bin/perl
use strict;
use warnings;
use 5.10.0;

# see README.mkd and TODO for more info

use MIME::Base64;
use Digest::SHA qw(sha256 sha256_base64 hmac_sha256 hmac_sha256_base64);

# ----------------------------------------------------------------------

my $N  = 1_000_000;                            # ROMix iterations
my $sl = "$ENV{HOME}/.config/hap2.sitelist";

# other non-parametrised settings:
# - SHA256 as H in ROMix
# - unpack("L") as "Integerify" in ROMix

# ----------------------------------------------------------------------

# get site nickname from command line
my $sn = shift;
print_nicks() unless $sn;
die "\nneed site nickname\n" unless $sn;

# get site details from sitelist file
my %sd = read_sl($sn);
die "could not find site with nickname '$sn'\n" unless $sd{site};
die "nickname '$sn' does not specify a user\n"  unless $sd{user};
$sd{salt} ||= 1;

# create the internal salt, to be used in the hap2() function
my $ss = "$sd{user}+$sd{salt}\@$sd{site}";
# TODO: read maxlen, special, UC/lc, and other constraints

print "\nmaster password: ";
my $mp = read_s();
die "need master password\n" unless $mp;

# special bypass routine for old hap
if ( $sd{sec} eq 'hap' ) {
    show( hap($mp) );
    exit;
}

# print, xsel, etc...
show( hap2( $ss, $mp ) );

# ----------------------------------------------------------------------

sub hap2 {
    my ( $ss, $mp ) = @_;
    t_start();
    say "computing password for '$ss'";

    # convert to 256 bits :-)
    my $salt = sha256($ss);
    # everything is in 256 bits from now on

    # step 1 -- hmac with the master password
    my $h1 = hmac_sha256( $salt, $mp );
    my $h2 = ROMix($h1);
    my $h3 = hmac_sha256_base64( $salt, $h2 );
    print STDERR t_lap() . "\n";

    # customise the return for specific site needs
    my $h4 = site_cust($h3);

    return $h4;
}

sub hap {
    my $key = shift;

    if ( $sn eq 'gen' ) {
        my $sitenick = shift @ARGV or die "need sitenick";
        $sd{$sitenick} or die "sitenick '$sd{sitenick}' not found";
        my ( $user, $comment );
        ( $user, $sd{site}, $sd{salt}, $sd{check}, $comment ) = split ' ', $sd{$sitenick};
        say "\tuser    =   $user";
        say "\tsite    =   $sd{site}";
        say "\tcomment =   $comment" if $comment;
    }

    # hap's default salt is an empty string, unlike hap2
    $sd{salt} ||= '';

    my $data = $sd{site} . $sd{salt};
    $sd{len} ||= 14;

    my $sha;

    if ( eval "use Digest::SHA qw(hmac_sha1_base64); 1" ) {
        $sha = hmac_sha1_base64( $data, $key );
    } else {
        $sha = `echo -n '$data' | openssl sha1 -binary -hmac '$key' | openssl base64`;
    }
    return site_cust($sha);
}
# ----------------------------------------------------------------------

sub ROMix {
    my $in = shift;
    my ( $X, $i, @V, $j );

    $V[0] = $in;
    for ( $i = 1; $i <= $N; $i++ ) {
        $V[$i] = sha256( $V[ $i - 1 ] );
    }
    $X = $V[$N];
    print STDERR t_lap() . "\n";

    for ( $i = 1; $i <= $N; $i++ ) {
        $j = unpack( "L", $X ) % $N;
        $X = sha256( $X ^ $V[$j] );
    }

    return $X;
}

sub site_cust {
    my $h = shift;
    # $h is about 43 characters, normally.  We may need to chop it down, or
    # add special characters, etc., based on site specific needs.

    my $check = sha256_base64($h);
    if ( my $c = $sd{check} ) {
        die "FATAL: check value mismatch; possible wrong password entered\n" if $c ne $check;
    } else {
        say "consider adding\n    check   =   $check\nto $sl";
    }

    # len
    $h = substr( $h, 0, $sd{len} ) if $sd{len};

    # finally, add suffix if one is specified
    $h .= $sd{suffix} if $sd{suffix};

    return $h;
}

# ----------------------------------------------------------------------

# service routines

sub read_sl {
    my $sn = shift;
    my %h;

    local @ARGV = ($sl);
    while (<>) {
        next unless /^\s*($sn)[^=]*$/ .. /^$/;

        print unless $sn eq 'gen';
        s/#.*//;
        s/\s*$//;    # cut out trailing spaces
        next unless /^\s+(\S+)\s*=\s*(.*)/;
        die "\nWARNING: duplicate entry for '$1'\n\t'$2' overrides '$h{$1}'\n" if $h{$1};
        $h{$1} = $2;
    }

    return %h;
}

# this is much better than fiddling with hard-to-use modules like
# Term::ReadLine or installing non-core modules like Term::ReadKey.  I've
# never been a "pure perl" fanatic anyway :-)
sub read_s {
    my $in;
    $in = `/bin/bash -c 'read -s foo; echo \$foo'`;
    chomp($in);
    print "\n";
    return $in;
}

sub show {
    my $sha = shift;
    say $sha;
    # if $DISPLAY is set, set the X selection, wait, and clear it
    if ( $ENV{DISPLAY} ) {
        system("echo -n '$sha' | xsel -b");
        # clear out xsel if done (or user can Ctrl-C out)
        print "X selection buffer set; press enter to clear it:";
        <>;
        my $dummy = '#' x 160;
        system("echo -n '$dummy' | xsel -b");
        $dummy = '#' x 16;
        system("echo -n '$dummy' | xsel -b");
    }
}

sub dd {
    use Data::Dumper;
    for my $i (@_) {
        print STDERR "DBG: " . t_lap() . ": " . Dumper($i);
    }
}

sub ddh {
    dd [ unpack( "H*", +shift ) ];
}

{
    use Time::HiRes;
    my %start_times;

    sub t_start {
        my $name = shift || 'default';
        $start_times{$name} = [ Time::HiRes::gettimeofday() ];
    }

    sub t_lap {
        my $name = shift || 'default';
        return Time::HiRes::tv_interval( $start_times{$name} );
    }
}

sub print_nicks {
    local @ARGV = ($sl);

    while (<>) {
        say $1 if /^\s*([\w.-]+)[^=]*$/;
        last if $1 and $1 eq 'gen';
    }

    while (<>) {
        # atleast 3 fields after "="
        say "\t$1\t$2" if /^\s*([\w.-]+)\s*=\s*\S+\s+(\S+)\s+\S+/;
    }
}
